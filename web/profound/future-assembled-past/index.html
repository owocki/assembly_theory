<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Future Is Assembled From the Past - Assembly Theory</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #141e30 0%, #243b55 50%, #141e30 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 60px;
        }

        h1 {
            font-size: 3.5em;
            font-weight: 300;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #f093fb, #f5576c, #4facfe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.4em;
            color: #b0bec5;
            margin-bottom: 40px;
        }

        .assembly-pathway {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 40px;
            margin: 50px 0;
            position: relative;
        }

        .timeline-container {
            position: relative;
            margin: 40px 0;
        }

        .timeline-line {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(180deg, #f093fb, #f5576c, #4facfe);
            transform: translateX(-50%);
        }

        .timeline-item {
            position: relative;
            margin: 30px 0;
            display: flex;
            align-items: center;
        }

        .timeline-item:nth-child(odd) {
            flex-direction: row-reverse;
        }

        .timeline-content {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            width: 45%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .timeline-content:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.08);
        }

        .timeline-dot {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f093fb, #f5576c);
            border: 3px solid #243b55;
            z-index: 1;
        }

        .assembly-constraints {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 50px 0;
        }

        .constraint-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border-left: 4px solid #f5576c;
            position: relative;
            overflow: hidden;
        }

        .constraint-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent, rgba(245, 87, 108, 0.1));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .constraint-card:hover::before {
            opacity: 1;
        }

        .possibility-space {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 40px;
            margin: 50px 0;
            text-align: center;
        }

        .possibility-diagram {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 40px 0;
            flex-wrap: wrap;
            gap: 30px;
        }

        .possibility-node {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            transition: all 0.3s ease;
        }

        .past-node {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }

        .present-node {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            box-shadow: 0 0 30px rgba(240, 147, 251, 0.5);
        }

        .future-node {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            box-shadow: 0 0 30px rgba(79, 172, 254, 0.5);
            opacity: 0.6;
        }

        .arrow-connector {
            font-size: 48px;
            color: #f5576c;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .interactive-demo {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 40px;
            margin: 50px 0;
            text-align: center;
        }

        .demo-button {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }

        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(245, 87, 108, 0.3);
        }

        .concept-explanation {
            background: rgba(240, 147, 251, 0.1);
            border-left: 4px solid #f093fb;
            padding: 30px;
            margin: 40px 0;
            border-radius: 0 15px 15px 0;
        }

        .back-link {
            display: inline-block;
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            padding: 12px 30px;
            text-decoration: none;
            border-radius: 25px;
            margin-top: 40px;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(240, 147, 251, 0.3);
        }

        .assembly-node {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .node-past {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .node-present {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            box-shadow: 0 0 20px rgba(240, 147, 251, 0.5);
        }

        .node-future {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
            opacity: 0.6;
        }

        .node-possible {
            background: linear-gradient(135deg, #00f2fe, #4facfe);
            border: 2px dashed rgba(255, 255, 255, 0.5);
            opacity: 0.4;
        }

        .assembly-node:hover {
            transform: scale(1.2);
            z-index: 20;
        }

        .assembly-connection {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(240, 147, 251, 0.6), transparent);
            transform-origin: left center;
            z-index: 5;
        }

        .connection-active {
            animation: flowConnection 2s linear infinite;
        }

        @keyframes flowConnection {
            0% { background-position: -100px 0; }
            100% { background-position: 100px 0; }
        }

        .future-possibility {
            background: rgba(79, 172, 254, 0.1);
            border: 1px solid rgba(79, 172, 254, 0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .future-possibility:hover {
            background: rgba(79, 172, 254, 0.2);
            transform: translateY(-2px);
        }

        .node-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 100;
        }

        .node-tooltip.visible {
            opacity: 1;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5em; }
            .timeline-content { width: 90%; }
            .timeline-item { flex-direction: column !important; }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">‚Üê Back to Profound Implications</a>

        <div class="header">
            <h1>The Future Is Assembled From the Past</h1>
            <p class="subtitle">Tomorrow's complexity can only emerge from today's existing assembly pathways</p>
        </div>

        <div class="assembly-pathway">
            <h2 style="text-align: center; margin-bottom: 40px;">Assembly Inheritance Timeline</h2>
            
            <div class="timeline-container">
                <div class="timeline-line"></div>
                
                <div class="timeline-item">
                    <div class="timeline-content">
                        <h3>Atoms</h3>
                        <p>Basic elements forged in stars provide the foundation for all chemistry</p>
                    </div>
                    <div class="timeline-dot"></div>
                </div>
                
                <div class="timeline-item">
                    <div class="timeline-content">
                        <h3>Molecules</h3>
                        <p>Chemical bonds create new properties, enabling organic chemistry</p>
                    </div>
                    <div class="timeline-dot"></div>
                </div>
                
                <div class="timeline-item">
                    <div class="timeline-content">
                        <h3>Life</h3>
                        <p>Self-replicating systems emerge from existing molecular machinery</p>
                    </div>
                    <div class="timeline-dot"></div>
                </div>
                
                <div class="timeline-item">
                    <div class="timeline-content">
                        <h3>Intelligence</h3>
                        <p>Neural complexity builds on cellular information processing</p>
                    </div>
                    <div class="timeline-dot"></div>
                </div>
                
                <div class="timeline-item">
                    <div class="timeline-content">
                        <h3>Technology</h3>
                        <p>Human tools extend biological capabilities using accumulated knowledge</p>
                    </div>
                    <div class="timeline-dot"></div>
                </div>
                
                <div class="timeline-item">
                    <div class="timeline-content">
                        <h3>Future</h3>
                        <p>Unknown complexities will emerge from today's assembly foundations</p>
                    </div>
                    <div class="timeline-dot"></div>
                </div>
            </div>
        </div>

        <div class="possibility-space">
            <h2>The Constraint of History</h2>
            
            <div class="possibility-diagram">
                <div class="possibility-node past-node">
                    <span>Past<br>Assemblies</span>
                </div>
                
                <div class="arrow-connector">‚Üí</div>
                
                <div class="possibility-node present-node">
                    <span>Current<br>Possibilities</span>
                </div>
                
                <div class="arrow-connector">‚Üí</div>
                
                <div class="possibility-node future-node">
                    <span>Future<br>Potential</span>
                </div>
            </div>
            
            <p style="opacity: 0.8;">Each stage constrains and enables the next. You can't skip steps in assembly.</p>
        </div>

        <div class="assembly-constraints">
            <div class="constraint-card">
                <h3>üîó Causal Chains</h3>
                <p>Future structures must be buildable from present components. You can't assemble what doesn't have precursors. This is why perpetual motion machines remain impossible.</p>
            </div>
            
            <div class="constraint-card">
                <h3>üèóÔ∏è Building Blocks</h3>
                <p>Complex futures require simple presents. DNA needed amino acids. Computers needed transistors. AI needs computation. Each level provides materials for the next.</p>
            </div>
            
            <div class="constraint-card">
                <h3>‚è±Ô∏è Time Requirements</h3>
                <p>Assembly takes time. The future can't arrive faster than assembly processes allow. Evolution took billions of years because each step had to be built and tested.</p>
            </div>
            
            <div class="constraint-card">
                <h3>üåê Path Dependence</h3>
                <p>History matters. The specific sequence of past assemblies determines which futures are accessible. Different histories lead to different possible tomorrows.</p>
            </div>
            
            <div class="constraint-card">
                <h3>üîÑ Feedback Loops</h3>
                <p>Present assemblies modify the landscape of future possibilities. Each innovation opens new pathways while closing others. Technology changes what technology can be.</p>
            </div>
            
            <div class="constraint-card">
                <h3>üí° Emergent Potential</h3>
                <p>While constrained by the past, the future holds genuine novelty. New combinations of existing elements create properties that couldn't be predicted from components alone.</p>
            </div>
        </div>

        <div class="concept-explanation">
            <h3>The Assembly Principle of Time</h3>
            <p>Assembly Theory reveals that the future isn't just influenced by the past‚Äîit's literally constructed from it. Every complex structure that will ever exist must be assembled from components that exist today, which were assembled from components that existed yesterday.</p>
            
            <p>This principle explains:</p>
            <ul>
                <li><strong>Why innovation is incremental:</strong> Revolutionary changes still build on existing foundations</li>
                <li><strong>Why some futures are impossible:</strong> They lack assembly pathways from the present</li>
                <li><strong>Why history shapes possibility:</strong> Past choices create the building blocks for future options</li>
                <li><strong>Why complexity increases:</strong> Each generation inherits and extends previous assemblies</li>
            </ul>
            
            <p>The future is not predetermined, but it is preconstrained. Tomorrow's miracles must be assembled from today's materials using processes discovered yesterday.</p>
        </div>


        <div class="assembly-chain-simulator">
            <h3 style="text-align: center; color: #f093fb; margin-bottom: 30px;">Assembly Chain Reaction</h3>
            <p style="text-align: center; color: #b0bec5; margin-bottom: 30px;">Click any past assembly to see how it constrains and enables the future</p>
            
            <div id="chainCanvas" style="position: relative; width: 100%; height: 500px; background: rgba(0, 0, 0, 0.3); border-radius: 20px; overflow: hidden;">
                <canvas id="assemblyChainCanvas" style="width: 100%; height: 100%;"></canvas>
                
                <div style="position: absolute; bottom: 20px; left: 20px; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 10px;">
                    <div style="color: #667eea; margin-bottom: 5px;">‚óè Past (Click to explore)</div>
                    <div style="color: #f093fb; margin-bottom: 5px;">‚óè Present (Active now)</div>
                    <div style="color: #4facfe; opacity: 0.6;">‚óè Future (Possible paths)</div>
                </div>
                
                <div id="nodeInfo" style="position: absolute; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 10px; display: none; max-width: 250px;">
                    <h4 style="margin: 0 0 10px 0; color: #f093fb;" id="nodeTitle">Node</h4>
                    <p style="margin: 0; font-size: 14px;" id="nodeDescription">Description</p>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button class="demo-button" onclick="resetChainSimulation()">Reset</button>
                <button class="demo-button" onclick="showAllPaths()">Show All Paths</button>
            </div>
        </div>

    </div>

    <script>
        // Animate timeline items on page load
        document.addEventListener('DOMContentLoaded', function() {
            const items = document.querySelectorAll('.timeline-item');
            items.forEach((item, index) => {
                item.style.opacity = '0';
                setTimeout(() => {
                    item.style.transition = 'opacity 0.5s ease';
                    item.style.opacity = '1';
                }, index * 200);
            });
            
            // Initialize chain simulator
            initChainSimulator();
        });
        
        // Assembly Chain Reaction Simulator
        let chainCanvas, chainCtx;
        let chainNodes = [];
        let chainConnections = [];
        let particles = [];
        let selectedNode = null;
        let animationFrame = null;
        
        const assemblies = {
            'atom': {
                name: 'Atoms',
                enables: ['molecule', 'star'],
                color: '#667eea',
                x: 100,
                y: 250,
                type: 'past',
                description: 'Fundamental building blocks forged in stellar cores',
                futures: ['Complex Chemistry', 'Nuclear Fusion', 'Heavy Elements']
            },
            'molecule': {
                name: 'Molecules',
                enables: ['life', 'crystal'],
                color: '#764ba2',
                x: 100,
                y: 150,
                type: 'past',
                description: 'Chemical bonds creating new properties',
                futures: ['Organic Chemistry', 'Polymers', 'Self-Assembly']
            },
            'star': {
                name: 'Stars',
                enables: ['planet', 'elements'],
                color: '#667eea',
                x: 100,
                y: 350,
                type: 'past',
                description: 'Nuclear furnaces creating heavy elements',
                futures: ['Planetary Systems', 'Supernovae', 'Black Holes']
            },
            'life': {
                name: 'Life',
                enables: ['brain', 'ecosystem'],
                color: '#f093fb',
                x: 300,
                y: 200,
                type: 'present',
                description: 'Self-replicating information systems',
                futures: ['Intelligence', 'Biodiversity', 'Symbiosis']
            },
            'crystal': {
                name: 'Crystals',
                enables: ['semiconductor', 'mineral'],
                color: '#f093fb',
                x: 300,
                y: 100,
                type: 'present',
                description: 'Ordered atomic structures',
                futures: ['Electronics', 'Photonics', 'Quantum Devices']
            },
            'planet': {
                name: 'Planets',
                enables: ['atmosphere', 'geology'],
                color: '#f093fb',
                x: 300,
                y: 350,
                type: 'present',
                description: 'Gravitationally bound matter',
                futures: ['Habitable Worlds', 'Terraforming', 'Space Resources']
            },
            'brain': {
                name: 'Brains',
                enables: ['consciousness', 'technology'],
                color: '#4facfe',
                x: 500,
                y: 150,
                type: 'future',
                description: 'Information processing organs',
                futures: ['AI', 'Collective Intelligence', 'Mind Upload']
            },
            'ecosystem': {
                name: 'Ecosystems',
                enables: ['biosphere', 'civilization'],
                color: '#4facfe',
                x: 500,
                y: 250,
                type: 'future',
                description: 'Interconnected living systems',
                futures: ['Global Consciousness', 'Synthetic Biology', 'Gaia']
            },
            'technology': {
                name: 'Technology',
                enables: ['ai', 'space'],
                color: '#00f2fe',
                x: 700,
                y: 200,
                type: 'future',
                description: 'Tools extending biological capabilities',
                futures: ['Singularity', 'Post-Human', 'Cosmic Engineering']
            }
        };
        
        function initChainSimulator() {
            chainCanvas = document.getElementById('assemblyChainCanvas');
            chainCtx = chainCanvas.getContext('2d');
            
            // Set canvas size
            chainCanvas.width = chainCanvas.offsetWidth;
            chainCanvas.height = chainCanvas.offsetHeight;
            
            // Create nodes
            for (let key in assemblies) {
                const assembly = assemblies[key];
                chainNodes.push({
                    id: key,
                    ...assembly,
                    radius: 25,
                    pulsePhase: Math.random() * Math.PI * 2
                });
            }
            
            // Add click handler
            chainCanvas.addEventListener('click', handleChainClick);
            chainCanvas.addEventListener('mousemove', handleChainHover);
            
            // Start animation
            animateChain();
        }
        
        function handleChainClick(e) {
            const rect = chainCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicked on a past node
            const clickedNode = chainNodes.find(node => {
                const dx = x - node.x;
                const dy = y - node.y;
                return node.type === 'past' && Math.sqrt(dx * dx + dy * dy) < node.radius;
            });
            
            if (clickedNode) {
                selectedNode = clickedNode;
                activateAssemblyChain(clickedNode);
            }
        }
        
        function handleChainHover(e) {
            const rect = chainCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const hoveredNode = chainNodes.find(node => {
                const dx = x - node.x;
                const dy = y - node.y;
                return Math.sqrt(dx * dx + dy * dy) < node.radius;
            });
            
            const infoDiv = document.getElementById('nodeInfo');
            if (hoveredNode) {
                document.getElementById('nodeTitle').textContent = hoveredNode.name;
                document.getElementById('nodeDescription').textContent = hoveredNode.description;
                infoDiv.style.display = 'block';
                chainCanvas.style.cursor = hoveredNode.type === 'past' ? 'pointer' : 'default';
            } else {
                infoDiv.style.display = 'none';
                chainCanvas.style.cursor = 'default';
            }
        }
        
        function activateAssemblyChain(startNode) {
            // Clear existing connections
            chainConnections = [];
            particles = [];
            
            // Reset all nodes
            chainNodes.forEach(node => {
                node.active = false;
                node.opacity = 0.3;
            });
            
            // Activate the chain
            const queue = [startNode];
            startNode.active = true;
            startNode.opacity = 1;
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (current.enables) {
                    current.enables.forEach(enabledId => {
                        const enabledNode = chainNodes.find(n => n.id === enabledId);
                        if (enabledNode && !enabledNode.active) {
                            enabledNode.active = true;
                            enabledNode.opacity = 1;
                            queue.push(enabledNode);
                            
                            // Create connection
                            chainConnections.push({
                                from: current,
                                to: enabledNode,
                                particles: []
                            });
                        }
                    });
                }
            }
            
            // Create particles for each connection
            chainConnections.forEach(conn => {
                for (let i = 0; i < 5; i++) {
                    conn.particles.push({
                        progress: i * 0.2,
                        speed: 0.5 + Math.random() * 0.5,
                        size: 2 + Math.random() * 2
                    });
                }
            });
        }
        
        function animateChain() {
            chainCtx.clearRect(0, 0, chainCanvas.width, chainCanvas.height);
            
            // Draw connections
            chainConnections.forEach(conn => {
                chainCtx.strokeStyle = 'rgba(240, 147, 251, 0.3)';
                chainCtx.lineWidth = 2;
                chainCtx.beginPath();
                chainCtx.moveTo(conn.from.x, conn.from.y);
                chainCtx.lineTo(conn.to.x, conn.to.y);
                chainCtx.stroke();
                
                // Draw particles
                conn.particles.forEach(particle => {
                    particle.progress += particle.speed * 0.01;
                    if (particle.progress > 1) particle.progress = 0;
                    
                    const x = conn.from.x + (conn.to.x - conn.from.x) * particle.progress;
                    const y = conn.from.y + (conn.to.y - conn.from.y) * particle.progress;
                    
                    chainCtx.fillStyle = 'rgba(240, 147, 251, 0.8)';
                    chainCtx.beginPath();
                    chainCtx.arc(x, y, particle.size, 0, Math.PI * 2);
                    chainCtx.fill();
                });
            });
            
            // Draw nodes
            chainNodes.forEach(node => {
                // Update pulse
                node.pulsePhase += 0.02;
                const pulseFactor = node.active ? 1 + Math.sin(node.pulsePhase) * 0.1 : 1;
                const radius = node.radius * pulseFactor;
                
                // Draw node
                chainCtx.globalAlpha = node.opacity || 1;
                chainCtx.fillStyle = node.color;
                chainCtx.beginPath();
                chainCtx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                chainCtx.fill();
                
                // Draw glow for active nodes
                if (node.active) {
                    chainCtx.shadowBlur = 20;
                    chainCtx.shadowColor = node.color;
                    chainCtx.fill();
                    chainCtx.shadowBlur = 0;
                }
                
                // Draw label
                chainCtx.fillStyle = '#fff';
                chainCtx.font = '12px sans-serif';
                chainCtx.textAlign = 'center';
                chainCtx.fillText(node.name, node.x, node.y + radius + 20);
                
                chainCtx.globalAlpha = 1;
            });
            
            // Draw time labels
            chainCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            chainCtx.font = '16px sans-serif';
            chainCtx.textAlign = 'center';
            chainCtx.fillText('PAST', 100, 50);
            chainCtx.fillText('PRESENT', chainCanvas.width / 2, 50);
            chainCtx.fillText('FUTURE', chainCanvas.width - 100, 50);
            
            // Draw future possibilities for selected node
            if (selectedNode && selectedNode.futures) {
                chainCtx.fillStyle = 'rgba(79, 172, 254, 0.6)';
                chainCtx.font = '11px sans-serif';
                selectedNode.futures.forEach((future, index) => {
                    const x = chainCanvas.width - 150;
                    const y = 150 + index * 30;
                    chainCtx.fillText('‚Üí ' + future, x, y);
                });
            }
            
            animationFrame = requestAnimationFrame(animateChain);
        }
        
        function resetChainSimulation() {
            selectedNode = null;
            chainConnections = [];
            particles = [];
            
            chainNodes.forEach(node => {
                node.active = false;
                node.opacity = 1;
            });
        }
        
        function showAllPaths() {
            chainConnections = [];
            
            chainNodes.forEach(node => {
                node.active = true;
                node.opacity = 1;
                
                if (node.enables) {
                    node.enables.forEach(enabledId => {
                        const enabledNode = chainNodes.find(n => n.id === enabledId);
                        if (enabledNode) {
                            chainConnections.push({
                                from: node,
                                to: enabledNode,
                                particles: []
                            });
                        }
                    });
                }
            });
            
            // Add particles
            chainConnections.forEach(conn => {
                for (let i = 0; i < 3; i++) {
                    conn.particles.push({
                        progress: Math.random(),
                        speed: 0.3 + Math.random() * 0.3,
                        size: 2
                    });
                }
            });
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (chainCanvas) {
                chainCanvas.width = chainCanvas.offsetWidth;
                chainCanvas.height = chainCanvas.offsetHeight;
            }
        });
    </script>
</body>
</html>